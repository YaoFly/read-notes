# 深入理解Java虚拟机

## 运行时内存局域

### 方法区（Method Area/Non-Heap）
线程共享  

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
  
### 堆（Heap）
线程共享    

存放对象实例，是垃圾收集器管理的主要区域，也成"GC"堆。不需要连续的内存，可选择固定大小或者可扩展。
### 虚拟机栈（VM Stack）
线程私有    

用于存储局部变量表，操作数，动态链接，方法出口等信息。为虚拟机执行Java方法（也就是字节码）服务
### 本地方法栈（Native Method Stack）
线程私有    

为使用到的Native方法服务
### 程序计数器（Program Counter Register）
线程私有  

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、
线程恢复等基础功能都需要依赖这个计数器来完成。  
此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 

### 运行时常量池（Runtime Constant Pool）
方法去的一部分，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。  
动态性:运行期间也可能将新的常量放入池中（例如String类的intern()方法）

### 直接内存（Direct Memory）
用于NIO使用Native函数库直接分配堆外内存，不属于运行时内存区域。不会受到Java堆大小的限制，但是受本机总内存大小以及处理器寻址空间的限制。

## 垃圾回收 Garbage collection, GC

### 可达性分析算法
用过一系列成为“GC Roots”的的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用连，当一个对象到GC Roots
没有任何引用链项链时，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）引用的对象。

### 对象引用
在JDK1.2之后，Java堆引用的概念进行了扩充
* 强引用 ---- 类似"Object obj = new Object()"这类的引用，只要强引用还存在，GC永远不会回收掉被引用的对象。
* 软引用 ---- 在系统将要发生内存溢出异常之前回收，如果回收后依然内存不足，抛出内存溢出异常（SoftReference类实现）
* 弱引用 ---- 只生存到在下一次GC发生之前（WeakReference类实现）
* 虚引用 ---- 无法通过虚引用来取得一个对象实例，唯一目的是能在这个对象被GC回收时收到一个系统通知（PhantomReference类实现）

### 垃圾收集算法
当代商业虚拟机的垃圾收集都采用"分代收集"算法，一般是把Java分为新生代和老年代，在新生代，每次GC都有大批对象死去，少量存活，那就选用复制
算法，老年代对象存活率高，没有额外空间进行分配担保，就必须使用"标记-清理"或者"标记-整理"算法来回收。



